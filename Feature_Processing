# feature_engineering.py

import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score


# ---------------------------------------------------------------------
# GEOMETRIC FEATURES
# ---------------------------------------------------------------------

def compute_geom_features_from_coords(coords_df: pd.DataFrame) -> dict:
    """
    Given coordinates DataFrame with columns ['x', 'y'], compute simple geometric features:
    - max thickness (t/c)
    - mean thickness
    - max / min camber and |camber|max
    - nose region thickness (proxy for nose radius)
    - number of points
    """
    df = coords_df.copy()

    # Normalize chord to [0, 1] if needed
    x_min, x_max = df["x"].min(), df["x"].max()
    if not np.isclose(x_min, 0.0) or not np.isclose(x_max, 1.0):
        df["x"] = (df["x"] - x_min) / (x_max - x_min)

    grouped = df.groupby("x")
    y_max = grouped["y"].max()
    y_min = grouped["y"].min()
    thickness = y_max - y_min
    camber = 0.5 * (y_max + y_min)

    t_c_max = thickness.max()
    t_c_mean = thickness.mean()
    c_max = camber.max()
    c_min = camber.min()
    c_abs_max = camber.abs().max()

    # Nose region proxy: thickness near leading edge (x <= 0.05)
    nose_region = thickness.loc[thickness.index <= 0.05]
    nose_thickness_mean = nose_region.mean() if len(nose_region) else np.nan

    return {
        "t_c_max": float(t_c_max),
        "t_c_mean": float(t_c_mean),
        "camber_max": float(c_max),
        "camber_min": float(c_min),
        "camber_abs_max": float(c_abs_max),
        "nose_thickness_mean": float(nose_thickness_mean),
        "num_points": int(len(df)),
    }


# ---------------------------------------------------------------------
# AERODYNAMIC FEATURES
# ---------------------------------------------------------------------

def compute_cl_alpha_linear_fit(
    polar_df: pd.DataFrame,
    alpha_col: str = "alpha",
    cl_col: str = "cl",
    alpha_min: float = -2.0,
    alpha_max: float = 8.0,
):
    """
    Fit a linear model Cl = a * alpha + b over a restricted alpha range (quasi-linear).

    Returns:
        slope_a, intercept_b, r2
    """
    if alpha_col not in polar_df.columns or cl_col not in polar_df.columns:
        raise ValueError(f"Polar table must contain '{alpha_col}' and '{cl_col}'")

    df = polar_df[[alpha_col, cl_col]].dropna()
    mask = (df[alpha_col] >= alpha_min) & (df[alpha_col] <= alpha_max)
    df_lin = df[mask]

    if len(df_lin) < 5:
        raise ValueError("Not enough points in the chosen linear region")

    X = df_lin[[alpha_col]].values
    y = df_lin[cl_col].values

    reg = LinearRegression()
    reg.fit(X, y)
    y_pred = reg.predict(X)
    r2 = r2_score(y, y_pred)

    return float(reg.coef_[0]), float(reg.intercept_), float(r2)


def compute_stall_angle(
    polar_df: pd.DataFrame, alpha_col: str = "alpha", cl_col: str = "cl"
) -> float:
    """
    Define stall angle as the alpha at which Cl reaches its maximum value.

    You can later refine to detect first local max or a certain Cl-drop threshold.
    """
    df = polar_df[[alpha_col, cl_col]].dropna()
    idx_max = df[cl_col].idxmax()
    stall_alpha = df.loc[idx_max, alpha_col]
    return float(stall_alpha)
